/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BrowserInterface
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/utils.ts
var import_obsidian = require("obsidian");
function getTabsFromMarkdown(markdown) {
  const lines = markdown.split("\n").filter((line) => {
    var _a;
    return ((_a = line.split(" ")[1]) == null ? void 0 : _a[0]) === "!";
  });
  const tabs = lines.map((line) => {
    const [favIconCell, titleCell] = line.slice(1, -2).split(" | ");
    const url = titleCell.slice(titleCell.indexOf("(") + 1, titleCell.indexOf(")"));
    const title = titleCell.slice(titleCell.indexOf("[") + 1, titleCell.indexOf("]"));
    const favIconUrl = favIconCell.slice(favIconCell.indexOf("(") + 1, favIconCell.indexOf(")"));
    return {
      favIconUrl,
      title,
      url
    };
  });
  return tabs;
}
function getTabFromMarkdown(line) {
  const [favIconCell, titleCell] = line.slice(1, -2).split(" | ");
  const url = titleCell.slice(titleCell.indexOf("(") + 1, titleCell.indexOf(")"));
  const title = titleCell.slice(titleCell.indexOf("[") + 1, titleCell.indexOf("]"));
  const favIconUrl = favIconCell.slice(favIconCell.indexOf("(") + 1, favIconCell.indexOf(")"));
  return [
    {
      favIconUrl,
      title,
      url
    }
  ];
}
async function saveJson(json, directory) {
  const randomNum = Math.floor(1e3 + Math.random() * 9e3);
  const existingFile = this.app.vault.getFileByPath(
    `${directory}/browser-interface-open-queue-${randomNum}.json`
  );
  if (!existingFile) {
    await this.app.vault.create(
      `${directory}/browser-interface-open-queue-${randomNum}.json`,
      json + "\n"
    );
  } else {
    const currentContent = await this.app.vault.read(existingFile);
    await this.app.vault.modify(existingFile, currentContent + json + "\n");
  }
  console.log("JSON saved.");
}
function isDirectoryValid(directory) {
  return this.app.vault.getFolderByPath(directory) instanceof import_obsidian.TFolder;
}

// src/settings.ts
var import_obsidian2 = require("obsidian");
var BrowserInterfaceSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const directorySetting = new import_obsidian2.Setting(containerEl).setName("Browser directory").setDesc(
      "Set the directory where the browser windows will be saved. This must be the same directory as the chrome extension's directory."
    );
    if (this.plugin.settings.browserDirectory) {
      directorySetting.addText((text) => {
        var _a;
        return text.setValue((_a = this.plugin.settings.browserDirectory) != null ? _a : "");
      }).setDisabled(true);
      directorySetting.addButton((button) => {
        button.setButtonText("Clear directory").onClick(async () => {
          this.plugin.tearDownQueue();
          this.plugin.settings.browserDirectory = void 0;
          await this.plugin.saveSettings();
          this.display();
        });
      });
    } else {
      directorySetting.addText(
        (text) => {
          var _a;
          return text.setPlaceholder("Enter the directory path").setValue((_a = this.plugin.settings.browserDirectory) != null ? _a : "").onChange(async (value) => {
            this.plugin.settings.browserDirectory = value;
          });
        }
      ).addButton((button) => {
        button.setButtonText("Set directory").onClick(async () => {
          if (this.plugin.settings.browserDirectory === void 0)
            return;
          const directoryIsValid = isDirectoryValid(this.plugin.settings.browserDirectory);
          if (!directoryIsValid) {
            new import_obsidian2.Notice("The directory does not exist. Please try again.");
            return;
          }
          await this.plugin.saveSettings();
          this.display();
        });
      });
    }
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  browserDirectory: void 0
};
var BrowserInterface = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.setUpCommands();
    this.loadMetaBindTemplates();
    this.addSettingTab(new BrowserInterfaceSettingTab(this.app, this));
  }
  async loadMetaBindTemplates() {
    const metaBind = this.app.plugins.plugins["obsidian-meta-bind-plugin"];
    if (!metaBind) {
      new import_obsidian3.Notice("Please install the Meta Bind plugin.");
      return;
    }
    const templates = [
      {
        id: "browser-interface-extension-open-window",
        label: "Open window",
        style: "primary",
        actions: [{ type: "command", command: "browser-interface:open-window" }]
      },
      {
        id: "browser-interface-extension-open-tab",
        label: "Open tab",
        style: "primary",
        actions: [{ type: "command", command: "browser-interface:open-tab" }]
      },
      {
        id: "browser-interface-extension-delete-tab",
        label: "Delete tab",
        style: "destructive",
        actions: [{ type: "command", command: "browser-interface:delete-tab" }]
      }
    ];
    const currentTemplates = Array.from(
      metaBind.api.buttonManager.buttonTemplates.values()
    );
    const otherTemplates = currentTemplates.filter(
      (template) => !/^browser-interface-extension-/.test(template.id || "")
    );
    metaBind.api.buttonManager.setButtonTemplates([...otherTemplates, ...templates]);
  }
  setUpCommands() {
    this.addCommand({
      id: "open-window",
      name: "Open window",
      editorCallback: (editor, view) => {
        const directory = this.getBrowserDirectory();
        const tabs = getTabsFromMarkdown(editor.getValue());
        saveJson(JSON.stringify(tabs), directory);
        if (view.file !== null)
          this.app.vault.delete(view.file);
      }
    });
    this.addCommand({
      id: "open-tab",
      name: "Open tab",
      editorCallback: (editor) => {
        var _a;
        const lineNum = editor.getCursor().line;
        const lineText = editor.getLine(lineNum);
        if (((_a = lineText.split(" ")[1]) == null ? void 0 : _a[0]) !== "!")
          return;
        const directory = this.getBrowserDirectory();
        const tab = getTabFromMarkdown(lineText);
        saveJson(JSON.stringify(tab), directory);
        editor.replaceRange("", { line: lineNum, ch: 0 }, { line: lineNum + 1, ch: 0 });
      }
    });
    this.addCommand({
      id: "delete-tab",
      name: "Delete tab",
      editorCallback: (editor) => {
        var _a;
        const lineNum = editor.getCursor().line;
        const lineText = editor.getLine(lineNum);
        if (((_a = lineText.split(" ")[1]) == null ? void 0 : _a[0]) !== "!")
          return;
        editor.replaceRange("", { line: lineNum, ch: 0 }, { line: lineNum + 1, ch: 0 });
      }
    });
  }
  onunload() {
    this.tearDownQueue();
  }
  tearDownQueue() {
    const queue = this.app.vault.getFileByPath(
      `${this.settings.browserDirectory}/browser-interface-open-queue.json`
    );
    if (queue)
      this.app.vault.delete(queue);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getBrowserDirectory() {
    if (this.settings.browserDirectory === void 0 || !isDirectoryValid(this.settings.browserDirectory)) {
      new import_obsidian3.Notice("The directory does not exist. Please try again.");
      throw new Error("The directory does not exist. Please try again.");
    }
    return this.settings.browserDirectory;
  }
};

/* nosourcemap */